% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runSQLQuerySplit.R
\name{runSQLQuerySplit}
\alias{runSQLQuerySplit}
\title{ODBC Connection Template}
\usage{
runSQLQuerySplit(SQL, DB, ..., startDate = NA, endDate = NA,
  by = "1 month", altVar = NA, altVals = NA, altBy = 1,
  combine = TRUE)
}
\arguments{
\item{SQL}{A character string of the query to execute or a filename to run.}

\item{DB}{A character string of the name of the database to connect to. Must be a configured database in the Windows ODBC connection list.}

\item{...}{Arguments to pass to \code{\link{runSQLQuery}}.}

\item{startDate}{A \code{\link{Date}} specifying the beginning of the range to query. Optional.}

\item{endDate}{A \code{\link{Date}} specifying the end of the range to query. Optional.}

\item{by}{Increment of the date sequence. Optional. See 'Details'. Defaults to \code{'1 month'}.}

\item{altVar}{A \code{\link{character}} string specifying the name of the alternate field to replace in the SQL. Optional.}

\item{altVals}{A vector of elements (\code{character} or \code{numeric}) to pass as values to the alternate field. Optional.}

\item{altBy}{A \code{\link{numeric}} value, specifying how many items from \code{altVals} should be grouped together (the size of the groups). Optional.}

\item{combine}{A boolean (\code{TRUE}/\code{FALSE}) that specifies whether the output should be combined into one single \code{\link{data.table}} (\code{TRUE}) or a \code{\link{list}} of \code{data.table}s (\code{FALSE}). Defaults to \code{TRUE}.}
}
\value{
A \code{\link{data.table}} or \code{\link{list}} containing the output of the queries.
}
\description{
Wrapper to run SQL queries against a database
}
\details{
\code{SQL} can either be supplied as a direct SQL string, or the path and name of a file containing SQL. File types can be \code{'.txt'} or \code{'.sql'}. SQL passed must be a complete and correctly formed query.

If using the date functionality with \code{startDate} and \code{endDate}, SQL code passed must include both \code{&SD} and \code{&ED} as start and end date respectively. These placeholders are used to swap out the required date ranges determined by the function. The form should be \code{<date field> BETWEEN &SD AND &ED}.

If using the the alternative replacement functionality with \code{altVar} and \code{altVals}, SQL code passed should be (but is not exlicitly required to be) structured to look for this value in an \code{IN} list. e.g., \code{<alt field> IN (<altVar>)}. If \code{altBy} is anything other than \code{1}, then the SQL will result in an error, otherwise.

The \code{...} (dot) arguments are the optional arguments used by \code{\link{runSQLQuery}}. All required arguments for \code{runSQLQuery} are also required here.
For dates, \code{by} can be specified in several ways:
\itemize{
\item{A number, taken to be in days.}
\item{A object of class difftime.}
\item{A character string, containing one of "day", "week", "month", "quarter" or "year". This can optionally be preceded by a (positive or negative) integer and a space, or followed by "s".}
}
See \code{\link{seq.Date}} for further information about \code{by}.
When specifying a \code{'month'} value to \code{by}, the function will parse the months to full month dates (i.e. 2017-01-01 through 2017-01-31). However, if a \code{startDate} or \code{endDate} is supplied that lies in the middle of a month, the resulting query will pull for only the dates that fall within the start/end date range.
If passing a list of text values to \code{altVals}, elements must be encoded with proper quotations. e.g., c("'ABC'","'DEF'","'GHI'").
}
\examples{

dt <- runSQLQuerySplit(SQL = 'Example.sql', DB='DBName',
            verbose = TRUE, creds=creds,
            replacements = list('&BEID' = "'008'"),
            startDate = as.Date('2017-01-05'),
            endDate = as.Date('2017-01-10'),
            by = '1 day')
            
dt <- runSQLQuerySplit(SQL = 'SELECT * FROM TABLE WHERE DATE BETWEEN &SD AND &ED', DB='DBName',
            verbose = TRUE, creds=creds,
            replacements = list('&BEID' = "'008'"),
            startDate = as.Date('2017-01-05'),
            endDate = as.Date('2017-03-10'),
            by = '1 month')
            
dt <- runSQLQuerySplit(SQL = SQL, DB = 'DBName', 
            verbose = TRUE, creds=creds,
            altVar = '&OIP', 
            altVals = c("'GAL'","'CNA'","'NYF'","'FIR'"), 
            altBy = 2)
            
dt <- runSQLQuerySplit(SQL = SQL, DB = 'DBName',
            verbose = TRUE, creds=creds,
            startDate = as.Date('2017/12/01'),
            endDate = as.Date('2018/01/31'), 
            altVar = '&OIP', 
            altVals = c("'GAL'","'CNA'","'NYF'","'FIR'"), 
            verbose = TRUE, 
            altBy = 2)
}
\seealso{
\code{\link{runSQLQuery}}, \code{\link{seq.Date}}
}
\keyword{connections}
\keyword{database}
\keyword{interface}
\keyword{io}
\keyword{methods}
